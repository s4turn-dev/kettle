## О проекте
Данный проект — моя реализация тестового задания на вакансию джуна в компанию ITOB. Проект представляет из себя CLI-приложение взаимодействия с моделью электрочайника.
## Содержание
1. [Дисклеймер](#дисклеймер)
2. [Для ITOB](#для-itob)
3. [Установка и запуск](#установка-и-запуск)
4. [Инструкция пользования](#инструкция-пользования)
5. [Документация](#документация)
## Дисклеймер
По ТЗ тестового задания чайник, если включен, должен каждую секунду сообщать температуру воды, и одновременно с этим поддерживать возможность пользователя в любой момент закончить выполнение программы.

У меня не было представления о том, как `print()` раз в секунду и постоянный `input()` возможно совместить в рамках одноэкранного консольного приложения, поэтому я пришел к мысли, что мне нужен **ввод с таймаутом**. Вокруг этой мысли построена вся архитектура: например, такие методы класса чайника как `cool()` или `boil()` написаны с рассчетом на понижение/повышение температуры _раз в секунду_, а красивый динамично обновляемый интерфейс — просто строка, которая раз в секунду заново клеится из новых данных.

Самым большим минусом этой реализации на практике стало неудобство использования: будьте готовы к тому, что на ввод команды и нажатие `Enter` у вас есть всего секунда, до того как интерфейс обновится и сотрет то, что вы успели ввести. В теории же, мне кажется, что такой костыль может вставить в колеса палки сильно б*о*льших размеров, чем просто неудобство пользования. Однако эта реализация — то, к чему у меня получилось придти.  
## Для ITOB
Привет! Хотел только сказать, что тестовое было очень интересным, большая его часть для меня была новым опытом: я впервые воспользовался гитом для хранения собственного проекта, писал README, документировал проект серьезнее, чем комментарии и строки, и многое другое. 

Желаю, чтобы проверка прошла гладко, и надеюсь, что закончится она оффером на мое имя ;^)

Хорошего дня!
## Установка и запуск
Проект требует запуска от имени Python 3.10+. Работоспособность проекта успешно прошла проверку на разных машинах под Linux Ubuntu 18.06 и Linux Arch ?, и закончилась крахом на Windows 10. Вкратце, когда я тестировал работоспособность, у меня возникла большая головная боль с локальными импортами, в которых я до сих пор как в дремучем лесу, и в дедлайн-день я, проводя генеральные репетиции, пофиксил запуск под Linux и поломал его для Windows.

Короче: Python 3.10, ОС Linux — должно работать.
1. Скопируйте репозиторий, используя команду `git clone`
2. Инициализируйте и активируйте виртуальное окружение
3. Установите зависимости, используя команду `pip install -r requirements.txt`
#### Для CLI
Выполните команду `python main.py` в своем терминале, находясь в корневой директории проекта.
#### Для web GUI на Flask
 Выполните команду `python server.py` в своем терминале, находясь в корневой директории проекта.
## Инструкция пользования
#### CLI
После того, как вы запустили проект, вас встретит интерфейс чайника, который представляет из себя три секции: историю температуры и сообщений, текущее состояние чайника и командную панель. Введите номер команды и нажмите `Enter`, чтобы выполнить ее. Для выхода из приложения необходимо выключить чайник (предварительно включив его, см. [Дисклеймер](#дисклеймер)). 

На данный момент чайник поддерживает 3 команды: включение/отключение, начало/остановка кипячение и внесение воды. Чтобы вскипятить чайник, необходимо, чтобы он был включен и в нем была вода. Процесс внесения воды происходит после того, как была отдана соответствующая команда: вам будет предложено указать количество добавляемой воды. **Предупреждение:** осторожно, не разлейте.
#### Web-приложение
С переходом на домашнюю страницу приложения вы увидите совсем простенькую страничку, содержающую два не таких простеньких блока: блок с информацией о чайнике и блок панели управления. Интерфейс интуитивно понятен, однако он не делится последними сообщениями чайника (которые тем не менее продолжают логироваться), поэтому не удивляйтесь, если у вас не получается заставить чайник кипятиться: либо вы не включили его, либо не налили в него воды — а это два обязательных для кипячения условия :^)
## Документация
### Глоссарий
- _логирует_ — вызывает метод **full_log()** класса Logger с указанным в контексте сообщением в качестве параметра.
### kettle/config.py
Конфиг-файл с константами, задающими поведение чайника.
- **DB_FILEPATH** (str) — путь до файла базы данных логов
- **KETTLE_CAPACITY** (float) — максимальная вместимость чайника
- **LOG_LINES_AMOUNT_FOR_SCREEN** (int) — количество сообщений для фетча из базы данных
- **SHOW_KETTLE_STATUS** (bool) — логический рычаг для включения отображения некоторой информации о состоянии чайника в интерфейс CLI
- **TEMPERATURE_MIN** (float) — минимальная температура воды
- **TEMPERATURE_MAX** (float) — максимальная температура воды
- **TXT_FILEPATH** (str) — путь до текстового файла логов
### BasicKettle(_model, version_)
Базовый класс, который реализует ряд функций электрочайника.

Параметры:
- **model** (str) — название модели чайника
- **version** (int) — номер версии модели

<details><summary>Атрибуты</summary>
<p>

- **boiling\_time\_left** (int) — число секунд, оставшееся до конца кипячений
- **current\_temperature** (float) — текущая температура воды
- **isBusy** (bool) — кипятит ли чайник воду
- **isPowered** (bool) — включен ли чайник
- **isWaitingWater** (bool) — ожидает ли чайник внесение воды
- **logger** (logger.Logger) — объект класса Logger
- **model** (str) — название модели
- **version** (int) — версия модели
- **water_amount** (float) — количество воды в чайнике

</p>
</details>

<details><summary>Методы</summary>
<p>

#### add_water(_inserted_amount_)
Вносит указанное количество воды в чайник и логирует сообщение об успехе.
- Если количество вносимой воды меньше или равно нулю, то вместо этого не делает ничего;
- Если по результату внесения воды значение атрибута **water_amount** превышает значение **KETTLE_CAPACITY** из конфига, то вместо этого присваивает значение **KETTLE_CAPACITY** и логирует сообщение о перелитой воде.    

Параметры:
- **inserted_amount** (float) — количество воды для внесения

#### boil()
Поднимает температуру воды на значение одной секунды кипячения и отнимает единицу из атрибута **boiling_time_left**.
- Если по результату вышеописанных действий значение атрибута **boiling_time_left** равняется нулю, то вызывает свой метод **switch_busy()** и логирует сообщение об окончании кипячения.

#### cool()
Понижает температуру воды на значение **TEMPERATURE_COOLING_STEP** из конфига.
- Если по результату значение атрибута **current_temperature** становится ниже значения **TEMPERATURE_MIN** из конфига, то присваивает это значение атрибуту.

#### generate_CLI_interface(_optional_message=None_)
Возвращает строку вида 
```
логи

---------------

опциональное сообщение

---------------
информационная панель
---------------
командная панель
```
Параметры:
- **optional_message** (str | None) — строка для отображения в дополнение к остальному интерфейсу.

#### is_empty()
Возвращает _True_, если значение атрибута **water_amount** равняется нулю, иначе возвращает _False_.

#### is_full()
Возвращает _True_, если значение атрибута **water_amount** равняется значению **KETTLE_CAPACITY** из конфига, иначе возвращает _False_.

#### switch_busy()
Присваивает атрибуту **boiling_time_left** значение **SECONDS_TO_BOIL** из конфига, инвертирует значение атрибута **isBusy** и логирует сообщение о его новом значении.
- Если значение атрибута **isPowered** не истинно, то вместо этого логирует сообщение о том, что чайник выключен;
- Если оба результат метода **is_empty()** и значение атрибута **isBusy** ложны, то вместо этого логирует сообщение о том, что чайник пуст.

#### switch_powered()
Инвертирует значение атрибута **isPowered** и логирует сообщение о его новом значении.

#### switch_waiting_water()
Инвертирует значение атрибута **isWaitingWater**.

</p>
</details>

### MiMak1(BasicKettle)
Существует исключительно для того, чтобы задать чайнику имя (модель-версия), а также изменить поведение метода **switch_waiting_water()**, поскольку мне показалось, что у базового чайника проблем с добавлением воды во время кипячения быть не должно.
<details><summary>Методы</summary>
<p>

#### switch_waiting_water()
Инвертирует значение атрибута **isWaitingWater**.
- Если значение атрибута **isBusy** истинно, то вместо этого логирует сообщение о неподдерживаемости функции добавления воды во время кипячения.

</p>
</details>

### Logger(_db_filepath, txt_filepath_)
Класс, выполняющий функции записи сообщений в текстовик и в базу данных SQLite.

Параметры:
- **db_filepath** (str) — путь до целевого файла базы данных
- **txt_filepath** (str) — путь до целевого текстового файла

<details><summary>О базе данных</summary>
<p>

Для работы класса требуется, чтобы база данных имела таблицу с именем `logs` вида
```
CREATE TABLE logs(
id INTEGER PRIMARY KEY AUTOINCREMENT,
message TEXT NOT NULL,
date_mark DATE NOT NULL,
time_mark TIME NOT NULL);
```
Значения **date_mark** и **time_mark** для `INSERT` запросов генерируются в момент вызова метода **log_to_db()** и являются результатами вызовов **datetime.datetime.today().date()** и **datetime.datetime.today().time()** соответственно. 
</p>
</details>

Класс AsyncLogger, оставшийся в проекте, умеет все совершенно то же самое, однако я не стал включать его в документацию, поскольку в реализации приложения он не используется.

<details><summary>Атрибуты</summary>
<p>

- **db_filepath** (str) — путь до файла базы данных
- **txt_filepath** (str) — путь до текстового файла

</p>
</details>

<details><summary>Методы</summary>
<p>

#### full_log(_message_)
По очереди вызывает методы **log_to_db()** и **log_to_txt()** с переданным сообщением в качестве параметра.

Параметры:
- **message** (str) — сообщение для записи

#### log_to_db(_message_)
Совершает `INSERT` запрос в базу данных.

Параметры:
- message (str) — текст для записи

#### log_to_txt(_message, prettify=False_)
Совершает запись в текстовый файл.

Параметры:
- **message** (str) — текст для записи
- **prettify** (bool) — если истинно, то добавит перед записываемым текстом приставку вида \[ЧАС:МИНУТА:СЕКУНДА\]

#### select_last_x_messages_from_db(_amount=50_)
Выбирает последние сообщения в переданном количестве в порядке last-in-first-out.

Параметры:
- **amount** (str) — количество сообщений для получения

</p>
</details>
